pro pass1, filename, showplot, debug_level, DEBUG5=debug5, BASIC1=basic1, $
	PRINTPLOTS=printplots, QUICKLOOK=quicklook, $
	SHOWIMAGE=showimage, SHOWCCD=showccd, SHOWHK=showhk, NOINIT=noinit, $
	BASELINE_CORRECTION=baseline_correction, PIXGEN=pixgen
; 
; $Id: pass1.pro 1.0 2001/11/05 13:23:35 burrows Exp $
;
;name	: pass1
;author : Dave Burrows
;date	: 01/09/95
;mod	: Modified extensively in November 2001 for the Swift XRT
;lang	: IDL

;purpose: This is the PASS1 program for XRT data processing.  The input
;	is a science data dump from the Swift XRT.  The input file must be
;	a data dump of a science Large Data Product file from the instrument.
;	Formats are defined in XRT-PSU-028.  Software can process raw files
;	from ITOS (including CCSDS and LDP headers), or pre-processed files
;	(with CCSDS and LCP headers stripped off - must have .sci extension).
;	Normal housekeeping messages will be processed by ITOS.
;	The input should be a single file containing at least one
;	complete Observation Snapshot.	This program does the following:
;
;	1) Strips the CCSDS headers and LDP headers from each data record,
;	    if needed (for all files except *.sci)
;	2) Checks format of Snapshot Header for errors
;	3) Processes all data reports and generates output files.
;		This version splits the science trailer into a text file
;		and several binary files and produces one FITS file for
;		each CCD frame.  Housekeeping data are also written out as
;		FITS files.
;	4) Checks format of Science Data Trailer for errors
;
;	The input file is processed in blocks of 1Mbit for historical reasons
;	    (to keep code as close to CUBIC PASS1 as possible).
;
;	Multiple LDPs can be included in the input file.  They are split into
;	separate .sci files, one for each LDP.  PASS1 can process all of
;	the output files generated by STRIP_HDR at one run if the input 
;	file is an ITOS telemetry file, but will only 
;	process one .sci file per run if the input file is a .sci file.
;
;	Input parameters:
;		filename = name of input data file.  User will be prompted
;			for this if it is not given as a parameter.
;		show_plot: controls display of XY plots (currently baselines,
;			mean rows, and raw spectra):
;			0: don't plot them
;			1: plot with default scaling (default option)
;			2: open interactive plot viewer to generate plots
;		debug_level: sets amount of debugging output (0=min, 10=max)
;	   Keywords:
;		/baseline_correction: sets the algorithm used for baseline
;			correction for photon-counting mode event data:
;			= 0: default, only subtract the baseline offset
;			= 1: based on the corner (diagonal) pixel values:
;				subtract the Gaussian-fitted mean of the
;				corner pixel values for each frame from all
;				of the pixels in that frame (after subtracting
;				the baseline offset).  This is preferred
;				for frames with abnormal baseline levels.
;		/basic: run in Basic Functional Test mode.  This reduces
;			the amount of output written to the .log file,
;			sets show_plot = 1, and plots out only the HK
;			channels needed to diagnose the Basic Functional
;			Test results (for CUBIC - not implemented yet for XRT)
;		/debug: set debug_level to 5 (over-ridden if debug_level
;			is set explicitly)
;		/noinit: this keyword inhibits initialization of the
;			common block variables.  Used by CUBIC.PRO.
;		/printplots: this keyword controls which plots are printed.
;			= 0: don't print any plots.
;			= 1: print only summary plots (from Snapshot Trailer
;					and housekeeping).  Default value.
;			= 2: print all plots (including all CCD histograms). 
;			If printplots is set, it turns off interactive plots.
;		/quicklook: this keyword runs the program in quick look mode.
;			This is similar to /basic, but all channels are plotted.
;			Output is reduced in order to produce a manageable level
;			for transmission to PSU by email.  Eventually, this
;			mode will automatically send the output files by email
;			to PSU.
;		/showimage: controls display of CCD and HK images:
;			= 0: no images displayed
;			= 1: displays CCD images in non-interactive mode
;			= 2: displays CCD and HK images using interactive widget.
;		    This keyword overrides the normal image display defaults
;			set by /noplots (showimage=1) and /quicklook (showimage=1).
;		/showccd: same as showimage, but only controls show_ccd_image.
;			Over-rides showimage for CCD images.
;		/showhk: same as showimage, but only controls show_hk_image.
;			Over-rides showimage for HK images.
;		/pixgen: sets plot boundaries of histograms to match the
;			pixel generator - only used for lab tests.
;
;	Error codes:
;	    0	no errors
;	    1	CHECK_POINTER_HEADER: found on-board pointer header ID
;			pattern instead of expected pattern
;	    2	CHECK_POINTER_HEADER: found TM bitstream ID instead of bit-swapped ID
;	    3	CHECK_POINTER_HEADER: found unknown bit pattern instead of pointer header ID
;	   11	START_NEW_DATA_BLOCK: at EOF - no new data to read
;	   12	START_NEW_DATA_BLOCK: found EOF - incomplete data block
;	   13	START_NEW_DATA_BLOCK: CCSDS Checksum error
;	   71	TAM: Reserved for use by tam.pro
;	   72	TAM: reserved for use by tam.pro
;	   73	TAM: reserved for use by tam.pro
;	   76	TAM: reserved for use by tam.pro
;	   77	TAM: reserved for use by tam.pro
;	   78	TAM: reserved for use by tam.pro
;	   81	STRIPCHART_MODE: EOF encountered before end of data frame
;	   91	various: EOF encountered before end of CCD header
;	   95	PHOTON_COUNTING: invalid X or Y position found
;	  101	CHECK_SCIENCE_DATA_HDR: found on-board pointer header ID pattern instead of
;					expected pattern (bit-swapped)
;	  102	CHECK_SCIENCE_DATA_HDR: found TM bitstream ID instead of bit-swapped ID
;	  103	CHECK_SCIENCE_DATA_HDR: found unknown bit pattern instead of pointer header ID
;	  151	APPEND_DATA_BLOCK: EOF encountered
;	  153	APPEND_DATA_BLOCK: EOT found earlier by CHECK_ECC_BYTES
;
;
;  INSTALLATION NOTES: when installing PASS1 on a new system, the
;	common block variables *_path located in file pass1_path_init.pro
;	must be set to point to the location of the indicated files on
;	the new system.
;
; Rev:
;   06/17/05 by JLR: fixed bug with snapshot not being reset after every LDP
;	04/23/04 by DNB: added checks on ccsds packets.  V3.11
;	04/21/04 by DNB: printed out first and last CCSDS packet times.  V3.10
;	01/13/03 by DNB: added Bad Pixel Table.  V3.9
;	11/14/03 by DNB: initialize last_mode at beginning of snapshot loop.
;		This is necessary in order to correctly calculate the 
;		exposure start time for frames in the case where the last
;		frame of the previous snapshot was in the same mode.
;		Bug found by Joe Hill on 11/14/03.
;	11/04/03 by DNB: added error checking on photon positions, better
;		stripcharts.  V3.7
;	08/18/03 by DNB: added spawned tasks to merge the event files
;		into a single file for faster processing by event browser.
;		Requires fmerge (FTOOL).  V3.6
;	06/04/03 by DNB: fixed bug with show_ccd_image (was switching to 2
;		for every snapshot trailer, and then displayed in wrong mode
;		for next bias map).  Set to V3.4.
;	05/21/03 by DNB: split timing catalog files, added timing debug file
;	04/10/03 by DNB: added timeline file.
;	04/08/03 by DNB: fixed bug that stopped when apparent CCSDS header ID
;		found while scanning for Frame Header ID.
;	04/07/03 by DNB: added some debugging info for unexpected CCSDS header
;	03/27/03 by DNB: fixed to handle EOT words properly.
;	09/10/02 by DNB: V2.1: bug fix in LRPD mode, modified some print statements, added
;		bias map.
;	09/08/02 by DNB: V2.0: released for Panter calibration
;	09/06/02 by DNB: V1.7: added image mode
;	09/05/02 by DNB: V1.6: added piled-up photodiode mode
;	09/04/02 by DNB: V1.5: added low-rate photodiode mode
;	09/02/02 by DNB: V1.4: added windowed timing mode
;	08/10/02 by DNB: added accumulated snapshot image; changed meanings
;		of baseline_correction options (removed original option 1)
;	08/09/02 by DNB: V1.3: incorporating photon-counting mode
;	05/02/02 by DNB: fixed bug in /printplots implementation
;	04/11/02 by DNB: deleted /noplots keyword, added /printplots keyword
;	03/12/02 by DNB: added pickfile for file error loop
;	02/23/02 by DNB: deleted path from input filename when selected via
;		pickfile.
;	02/09/02 by DNB: initialize split_type for each .sci file.  Changed 
;		definition of baseline_correction keyword.
;	02/08/02 by DNB: added check for presence of Snapshot Trailer
;	02/03/02 by DNB: moved HK cal file setup to after log file and error
;		file are opened.
;
; $Log: pass1.pro $
;

@pass1_common
;common ccd_hk_data	; TBD: stores CCD HK data for process_ccd_frame_hdr

close,/all		; close files in case any were left open by previous run

@pass1_path_init	; initialize paths for input files

version = 'V3.12'

; "declare" variable types/initialize variables

pc_files = 0
wt_files = 0
pd_files = 0
first_utc = 0.0d
last_utc = 0.0d

if not (keyword_set(noinit)) then begin
@pass1_init	; initialize common block variables.
endif

ID_type = 0
files_in = strarr(1)

GET_LUN, luin		; Get Logical Unit Numbers for input and output files
GET_LUN, luerr
GET_LUN, lulog
GET_LUN, lutimeline
GET_LUN, lustats
GET_LUN, luccsds

; Get email address
GET_LUN, lumail
openr,lumail,email_path, ERROR=ierr

email_address = ''
if (ierr eq 0) then readf,lumail,email_address
FREE_LUN, lumail

if (n_params() eq 0) then begin
;	read,'Enter name of XRT input file: ', filein
	filein = pickfile(title='Select XRT data file: ', $
		filter='*science*',/must_exist)
	path_pos = strpos(filein, '/', /reverse_search)
	filein = strmid(filein,path_pos+1)
endif else begin
	filein = filename
endelse

if (n_params() lt 2) then show_plot = 1 $
else show_plot = showplot

if (n_params() lt 3) then idebug = 0 $
else idebug = debug_level

if keyword_set(debug5) then idebug = 5

;idebug = 100

if keyword_set(basic1) then begin
	basic_test_mode = 1
	verbosity = 0
	show_plot = 1
endif

if keyword_set(baseline_correction) then begin
    case baseline_correction of
	0: baseline_correction_mode = 0
	1: baseline_correction_mode = 1
	else: begin
	    print, 'WARNING: invalid value for baseline_correction keyword: ', $
			baseline_correction
	    stop
	endelse
    endcase
endif

print_plots = 0
if keyword_set(printplots) then begin
	print_plots = printplots
	show_plot = 1
	show_ccd_image = 1
	show_hk_image = 1
endif

quick_look_mode = 0
if keyword_set(quicklook) then begin
	quick_look_mode = 1
	verbosity = 0
	show_plot = 0
	show_ccd_image = 0
	show_hk_image = 0
endif

if keyword_set(showimage) then begin
	show_ccd_image = showimage
	show_hk_image = showimage
endif
if keyword_set(showccd) then begin
	show_ccd_image = showccd
endif
if keyword_set(showhk) then begin
	show_hk_image = showhk
endif
pix_gen=0
if keyword_set(pixgen) then pix_gen = pixgen

; Check that file exists

openr,luin,filein,error=file_error
if (file_error ne 0) then repeat begin
	print,'Error opening input file.  Please try another file name.'
;	read,'Enter name of XRT input file: ', filein
	filein = pickfile(title='Select XRT data file: ', /must_exist)
	path_pos = strpos(filein, '/', /reverse_search)
	filein = strmid(filein,path_pos+1)
	openr,luin,filein,error=file_error
endrep until (file_error eq 0)
free_lun,luin

; Find the file extension (the string following the last period
;		in the file name)
start_pos = 0
new_pos = strpos(filein,'.',start_pos)
if (new_pos eq -1) then begin
	file_ext = ' '
endif else begin
	while (new_pos ne -1) do begin
		new_pos = strpos(filein,'.',start_pos)
		if (new_pos ne -1) then str_pos = new_pos
		start_pos = new_pos + 1
	endwhile
	file_ext = strmid(filein,str_pos+1,3)
endelse


; Now get the filename base
;	Check the file extension for special types:
;		.sci files have had CCSDS and LDP headers stripped off
if (file_ext eq 'sci') then begin
	repeat begin
		filebase = strmid(filein,0,str_pos)
		pos = str_pos
		str_pos = strpos(filein,'.',pos)
	endrep until (str_pos = -1)
;		other files need to be processed by STRIP_HDR before PASS1
endif else begin
	filebase = filein
endelse

; Set up error and log files

file_err = filebase + '.err'
openw,luerr,file_err
printf,luerr,'PASS1 ERROR FILE'
printf,luerr,'PASS1 ' + version + ' executed on XRT data file ', filein
printf,luerr,'     on ', runtime

file_log = filebase + '.log'
openw,lulog,file_log
printf,lulog,'PASS1 LOG FILE'
printf,lulog,'PASS1 ' + version + ' executed on XRT data file ', filein
printf,lulog,'     on ', runtime

file_timeline = filebase + '.timeline'
openw, lutimeline, file_timeline
printf,lutimeline,'PASS1 TIMELINE FILE'
printf,lutimeline,'PASS1 ' + version + ' executed on XRT data file ', filein
printf,lutimeline,'     on ', runtime

file_stats = filebase + '.stats'
openw, lustats, file_stats
printf,lustats,' OBS NUM  MODE     last_stop_time      readout_start       readout_stop        frame_start         frame_stop          delta  row_time xfer_time  exposure live_time'

file_ccsds = filebase + '.ccsds'
openw,luccsds,file_ccsds
printf,luccsds,'PASS1 CCSDS Headers'
printf,luccsds,'PASS1 ' + version + ' executed on XRT data file ', filein
printf,luccsds,'     on ', runtime
printf,luccsds,' '
printf,luccsds,'*********************************************************'
printf,luccsds,'Seq #  Size      CCSDS time  Prod #  Page #    Hdr ID'

print,'PASS1 ' + version + ' executed on XRT data file ', filein

; Set up housekeeping arrays
load_hk_tables

files_in[0] = filein
; Run  STRIP_HDR on raw CCSDS files from ITOS
if (file_ext ne 'sci') then begin
	print,''
	print,'Running STRIP_HDR to remove CCSDS headers ...'
	print,''
	strip_hdr, ccsds_hdr_id, filein, fileout
	files_in = fileout
endif
FREE_LUN, lutimeline

if (first_time gt 0.0) then begin
	printf,lulog,' '
	printf,lulog,format='(a,f20.6,a,a)','First CCSDS packet time: ', first_time, $
		' = ', itos_time(first_time,first_utc)
	printf,lulog,format='(a,f20.6,a,a)',' Last CCSDS packet time: ', last_time, $
		' = ', itos_time(last_time,last_utc)
	printf,lulog,format='(a,f20.6)',' Delta (seconds) = ', last_time-first_time
endif

printf,lulog,' '

; OPEN INPUT FILE(S), START PROCESSING DATA

found_snapshot_trailer = 0
split_type = uintarr(3,3)		; Initialize array
num_files = n_elements(files_in)
for ifile=0,num_files-1 do begin
    iframe = -1 		; reset frame count for diagnostic plots
    last_mode = -1		; reset check on XRT mode
    spectrum = fltarr(4096)	; reset cumulative spectrum
    if (lupccatalog ge 0) then begin
	free_lun,lupccatalog
	lupccatalog = -1
    endif
    if (luwtcatalog ge 0) then begin
	free_lun,luwtcatalog
	luwtcatalog = -1
    endif
    if (lupdcatalog ge 0) then begin
	free_lun,lupdcatalog
	lupdcatalog = -1
    endif

    print,' '
    print,' '
    print,'************************************************************'
    print,'************************************************************'
    print,'PASS1: STARTING MAIN PROCESSING LOOP' 
    printf,lulog,' '
    printf,lulog,' '
    printf,lulog,'************************************************************'
    printf,lulog,'************************************************************'
    printf,lulog,'PASS1: STARTING MAIN PROCESSING LOOP' 

    print,' '
;    print,'File status: '
;	help,/files

    filein = files_in[ifile]

    print,'PASS1: Opening input file ', filein
    printf,lulog,'PASS1: Opening input file ', filein
    get_lun,luin
    openr,luin,filein,/swap_if_little_endian
 
; Reset the file base
    ext_pos = strpos(filein,'.',/reverse_search)
    if (strmid(filein,ext_pos,4) eq '.sci') then $
	filebase = strmid(filein,0,ext_pos) $
    else filebase = filein

    print,'************************************************************'
    print,'************************************************************'
    print,' '
    printf,lulog,'************************************************************'
    printf,lulog,'************************************************************'
    printf,lulog,' '

    if (quick_look_mode) then begin
	printf,lulog,''
	printf,lulog,'PASS1: *** QUICK-LOOK MODE ***'
    endif

    ; Initialize variables that have to be reset every time loop starts

    buffer_pointer = 0 ; Initialize pointer to start at begininng of data buffer
    block_number = 0   ; Initialize block counter
    end_of_data = 0    ; Initialize flag
    process_hk = 0     ; Initialize flag
    START_NEW_DATA_BLOCK, buffer_pointer, error_code	; read first 1 Mbit block of data

    ; now process data frames

    ID_type = 0		; Initialize ID_type at beginning of file
    while (ID_type ge -1 and end_of_data lt 2) do begin

	ID_type = find_ID(buffer_pointer,ID)

	case ID_type of
		-1: begin
			if (buffer_pointer lt n_elements(data_buffer)-4) then begin
				eot_check = extract_long(buffer_pointer)
				buffer_pointer = buffer_pointer - 4
				if (eot_check eq '04e704e7'x) then begin
					print, 'Found EOT word (end of Snapshot) in input file at ', buffer_pointer
					printf,lulog,'Found EOT word (End of Snapshot) in input file at ', buffer_pointer
				endif
			endif
		    end
		1: begin
			print_error,0,1, ' '
			print_error,0,1, $
				'PASS1 ERROR: found possible unexpected CCSDS Header ID while searching for Frame Header ID'
			print_error,0,1, $
				'PASS1: dumping data buffer around error at offset ' $
				+ strtrim(string(buffer_pointer),2) + ':'
			if ((buffer_pointer mod 2) eq 1) then begin	; found on odd word
				print_error,0,1,'PASS1: NOTE THAT CCSDS ID WORD OCCURS ON ODD BYTE'
				print_error,0,1, $
					string(data_buffer[buffer_pointer-21:buffer_pointer-2], $
					format='(10(2z2.2,2x))')
				print_error,0,1, string(data_buffer[buffer_pointer-1:buffer_pointer+2], $
					format='(''*** '',2z2.2, '' '', 2z2.2, '' ***'')')
				print_error,0,1, $
					string(data_buffer[buffer_pointer+3:buffer_pointer+42], $
					format='(10(2z2.2,2x))')
			endif else begin					; found on even word
				print_error,0,1, $
					string(data_buffer[buffer_pointer-20:buffer_pointer-1], $
					format='(10(2z2.2,2x))')
				print_error,0,1, string(data_buffer[buffer_pointer:buffer_pointer+1], $
					format='(''*** '',2z2.2, '' ***'')')
				print_error,0,1, $
					string(data_buffer[buffer_pointer+2:buffer_pointer+41], $
					format='(10(2z2.2,2x))')
			endelse
			buffer_pointer = buffer_pointer + 2 ; skip past current word
		   end
		2: snapshot_header, buffer_pointer
		3: image_mode, buffer_pointer, error_code
		4: Piled_Up_Photodiode, buffer_pointer, error_code
		5: Low_Rate_Photodiode, buffer_pointer, error_code
		6: Windowed_Timing, buffer_pointer, error_code
		7: Photon_Counting, buffer_pointer, error_code
		8: CCD_Raw_Frame, buffer_pointer, error_code
		9: Bias_Map, buffer_pointer, error_code
		10: Bad_Pixel_Table, buffer_pointer, error_code
		11: CHECK_SNAPSHOT_TRL, buffer_pointer, error_code
		12: End_SNAPSHOT_TRL, buffer_pointer, error_code
	      else: begin
			print_error,0,1,'PASS1: unrecognized ID_type = ' + string(ID_type)
			if (buffer_pointer ge 9) then $
			    printf,lulog,format='(A,20Z4)','PASS1: buffer values near EOT words: ',$
			    data_buffer(buffer_pointer-9:buffer_pointer+10)
			
		    endelse
	endcase

	if (error_code ne 0) then print_error,0,1, $
		'***** Returned to PASS1 with error code: ' $
		+ strtrim(string(error_code)) + ' *****'

	if (idebug ge 10) then begin
		print,'PASS1: Looping in while loop at pointer=', buffer_pointer
		printf,lulog,'PASS1: Looping at pointer=',buffer_pointer
		printf,lulog,format='(a,z10)', $
			'PASS1: find_id returned ID_type = ', ID_type
	endif
;	help,/files
;	wait,1
    endwhile

    print,format="('Exiting PASS1 at block ', i, ', buffer pointer @', i, ' with ID = 0x', z8.8)", $
		block_number, buffer_pointer, id
    printf,lulog,format="('Exiting PASS1 at block ', i, ', buffer pointer @', i, ' with ID = 0x', z8.8)", $
		block_number, buffer_pointer, id

    file_status = fstat(luin)
    print,'     File pointer = ', file_status.cur_ptr,' ;  File size = ', $
		file_status.size
    printf,lulog,'     File pointer = ', file_status.cur_ptr,' ;  File size = ', $
		file_status.size

    ;*****************************************************************************
    ; Start Post-Processing

    ; Print CCD event splitting statistics

    print,' '
    print,'****************************************************************'
    print,'****************************************************************'
    print,'   STARTING POST-PROCESSING for file ', filein
    print,'****************************************************************'
    print,'****************************************************************'

; Check for presence of Snapshot Trailer in this LDP
    if (found_snapshot_trailer eq 0) then begin
	print_error,0,1,' '
	print_error,0,1,'****************************************************************'
	print_error,0,1,'PASS1: No Snapshot Trailer found in this LDP for Snapshot ' + strtrim(string(snapshot_number),2)
	print_error,0,1,'****************************************************************'
	print_error,0,1,' '
    endif
    found_snapshot_trailer = 0

    total_splits = total(split_type) - split_type[1,1] ; look at only splits
    total_charge = total(split_charge)
    if (total_splits gt 10) then begin
	print,''
	print,'Single Split Distribution and Average Charge Distribution Probabilities (%)'
	print,format='(3x, a17, 21x, a)', 'Single Splits (%)', 'Charge Distribution (%)'
	percent_split = fltarr(3,3)
	percent_charge = percent_split
	percent_split = split_type*100.0/total_splits
	percent_split[1,1] = 0.0			; remove central pixel
	percent_charge = split_charge*100.0/total_charge
	print, format='(3f7.2,19x,3f7.2)', percent_split[0:2,2], $
		percent_charge[0:2,2]
	print, format='(3f7.2,19x,3f7.2)', percent_split[0:2,1], $
		percent_charge[0:2,1]
	print, format='(3f7.2,19x,3f7.2)', percent_split[0:2,0], $
		percent_charge[0:2,0]

	printf,lulog,''
	printf,lulog,'Single Split Distribution and Average Charge Distribution Probabilities (%)'
	printf,lulog,format='(3x, a17, 21x, a)', $
		'Single Splits (%)', 'Charge Distribution (%)'
	printf,lulog, format='(3f7.2,19x,3f7.2)', percent_split[0:2,2], $
		percent_charge[0:2,2]
	printf,lulog, format='(3f7.2,19x,3f7.2)', percent_split[0:2,1], $
		percent_charge[0:2,1]
	printf,lulog, format='(3f7.2,19x,3f7.2)', percent_split[0:2,0], $
		percent_charge[0:2,0]

    endif

    ;; If a catalog file was opened, then close it here.
    if (lupccatalog ge 0) then begin
	free_lun,lupccatalog
	lupccatalog = -1
	pc_files = pc_files + 1
	pcfile = '1' + filebase + '.merged_pc_events.fits'
	print, ' ' 
	print,'Spawning job to merge PC event files'
	printf,lulog,' '
	printf,lulog,'Spawning job to merge PC event files into file: ', $
		strtrim(pcfile,2)
	command = 'fmerge @' + file_pc_catalog + ' ' + pcfile $
		+ ' "TIME,CCDFRAME,CCD_ID,CCDNODE,XRT_MODE,TYPE,CHIPX,CHIPY,' $
		+ 'RAWX,RAWY,DETX,DETY,PHAS" lastkey="MET_STOP,TSTOP"' $
		+ ' clobber=yes'
	spawn, command
    endif
    if (luwtcatalog ge 0) then begin
	free_lun,luwtcatalog
	luwtcatalog = -1
	wt_files = wt_files + 1
	wtfile = '1' + filebase + '.merged_wt_events.fits'
	print, ' '
	print,'Spawning job to merge WT event files'
	printf,lulog,' '
	printf,lulog,'Spawning job to merge WT event files into file: ', $
		strtrim(wtfile,2)
	command = 'fmerge @' + file_wt_catalog + ' ' + wtfile $
		+ ' "TIME,CCDFRAME,CCD_ID,CCDNODE,XRT_MODE,TYPE,CHIPX,CHIPY,' $
		+ 'RAWX,RAWY,DETX,DETY,PHA" lastkey="MET_STOP,TSTOP"' $
		+ ' clobber=yes'
	spawn, command
    endif
    if (lupdcatalog ge 0) then begin
	free_lun,lupdcatalog
	lupdcatalog = -1
	pd_files = pd_files + 1
	pdfile = '1' + filebase + '.merged_pd_events.fits'
	print, ' '
	print,'Spawning job to merge PD event files'
	printf,lulog,' '
	printf,lulog,'Spawning job to merge PD event files into file: ', $
		strtrim(pdfile,2)
	command = 'fmerge @' + file_lrpd_catalog + ' ' + pdfile $
		+ ' "TIME,CCDFRAME,CCD_ID,CCDNODE,XRT_MODE,TYPE,CHIPX,CHIPY,' $
		+ 'RAWX,RAWY,DETX,DETY,PHA" lastkey="MET_STOP,TSTOP"' $
		+ ' clobber=yes'
	spawn, command
    endif


    free_lun,luin

    if (accumulated_images gt 0) then begin
	; write out accumulated snapshot image
	print_debug,0,'Writing accumulated FITS image (' $
		+ strtrim(string(accumulated_images),2) + ' images)'
	file_ccd = filebase + '.snapshot_image.fits'
	old_show_ccd_image = show_ccd_image
	show_ccd_image=2
	writefits,file_ccd,snapshot_image
    accumulated_images = 0
    snapshot_image[*]=0
	show_ccd_image = old_show_ccd_image
    endif


    if ((n_elements(light_curve) gt 2) and (print_plots ge 1)) then begin
      if (iframe ge 1) then begin
	print,'sending plots to the printer'
	set_plot,'ps'
	device, /landscape
	!P.Multi = [0,1,3]
	plot, frame_count(0:iframe), light_curve(0:iframe), $
		title = 'CCD Light Curve (total/single)', xtitle='Frame #', $
		ytitle='# Events', yrange=[0,max(light_curve(0:iframe))]
	oplot, frame_count(0:iframe), single_events(0:iframe), $
		linestyle=1
	plot, frame_count(0:iframe), baseline(0:iframe), $
		title = 'CCD Mean Baseline (corner pixels)',  $
		xtitle='Frame #', ytitle='DN', $
		yrange=[min(baseline(0:iframe)), max(baseline(0:iframe))]
	plot, frame_count(0:iframe), readnoise(0:iframe), $
		title = 'CCD Readnoise (corner pixels)', xtitle='Frame #', $
		ytitle='DN (rms)'
;	XYOUTS,alignment=0.5,/device,9250,13000,size=1.1, $ ; portrait mode
	XYOUTS,alignment=0.5,/device,12375,18000,size=1.1, $
		'XRT CCD processing diagnostics from file ' + filein
	XYOUTS,alignment=0,/device,1000,-200,size=0.8,runtime

    ; plot cumulative histograms

	!P.Multi = 0
	xmin = min(cumulative_dn(where(cumulative_hist gt 0)))
	xmax = max(cumulative_dn(where(cumulative_hist gt 0)))
	yfit1 = gaussfit(cumulative_dn, cumulative_hist, a1, estimates=[10.0,0.0,10.0],nterms=3)
	plot, cumulative_dn, cumulative_hist, psym = 10, $
		title = 'Cumulative Corner Pixel Histogram', xtitle = 'DN', xrange=[xmin, xmax]
	oplot, cumulative_dn, yfit1

;	XYOUTS,alignment=0.5,/device,9250,13000,size=1.1, $	; portrait
	XYOUTS,alignment=0.5,/device,12375,18000,size=1.1, $
		'XRT CCD cumulative corner pixel histograms from file ' + filein
	XYOUTS,alignment=0,/device,1000,-200,size=0.8,runtime
	XYOUTS,alignment=0,/device,3500,15750,size=0.8,'A0 = ' $
		+ strtrim(string(a1(0)),2)
	XYOUTS,alignment=0,/device,3500,15125,size=0.8,'A1 = ' $
		+ strtrim(string(a1(1)),2)
	XYOUTS,alignment=0,/device,3500,14500,size=0.8,'A2 = ' $
		+ strtrim(string(a1(2)),2)
	XYOUTS,alignment=0,/device,3500,7300,size=0.8,'A0* = ' $
		+ strtrim(string(a2(0)),2)
	XYOUTS,alignment=0,/device,3500,6675,size=0.8,'A1* = ' $
		+ strtrim(string(a2(1)),2)
	XYOUTS,alignment=0,/device,3500,6050,size=0.8,'A2* = ' $
		+ strtrim(string(a2(2)),2)
	!P.Multi = 0
	device,/close
	spawn,'lpr -r idl.ps'

	set_plot,'X'
      endif
    endif

    if (process_hk ne 0) then begin
	free_lun,luhk
	process_hk_data
    endif
    if (basic_test_mode eq 1) then begin
	spawn,'a132 ' + file_err + ' | lpr'
	spawn,'a132 ' + file_log + ' | lpr'
    endif

;    if (quick_look_mode eq 1) and (email_address ne '') then begin
;	spawn,'/usr/bin/mail ' + email_address + ' < ' + file_log
;	spawn,'/usr/bin/mail ' + email_address + ' < ' + file_err
;    endif


    if (error_count ne 0) then begin
	print,' '
	print,' '
	print,'*** ', error_count, ' ERRORS DETECTED ***'
	print,'    Examine file ', file_err, ' for list of errors.'
    endif

endfor

close,/all
if (pc_files gt 0) then begin
	pc_cat = '0' + filebase + '.merged_pc_events.cat'
	print,'Spawning job to create PC event file catalog'
	command = 'ls 1*.merged_pc_events.fits > ' + pc_cat
	spawn, command
endif
if (wt_files gt 0) then begin
	wt_cat = '0' + filebase + '.merged_wt_events.cat'
	print,'Spawning job to create WT event file catalog'
	command = 'ls 1*.merged_wt_events.fits > ' + wt_cat
	spawn, command
endif
if (pd_files gt 0) then begin
	pd_cat = '0' + filebase + '.merged_pd_events.cat'
	print,'Spawning job to create PD event file catalog'
	command = 'ls 1*.merged_pd_events.fits > ' + pd_cat
	spawn, command
endif

print,''
print,'PASS1 terminating.  Use EB to examine X-ray spectra processed by PASS1'
print,''

end
